"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty")), _objectWithoutProperties = _interopDefault(require("@babel/runtime/helpers/objectWithoutProperties")), fields = require("@keystonejs/fields"), adapterKnex = require("@keystonejs/adapter-knex");

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

class AutoIncrementImplementation extends fields.Implementation {
  constructor(path, _ref = {}, context = {}) {
    let {gqlType: gqlType, isUnique: isUnique = !0, access: access = {}} = _ref, config = _objectWithoutProperties(_ref, [ "gqlType", "isUnique", "access" ]);
    "object" == typeof access && (access = _objectSpread({
      create: !1,
      update: !1,
      delete: !1
    }, access)), super(path, _objectSpread(_objectSpread({}, config), {}, {
      isUnique: isUnique,
      access: access
    }), context), this.gqlType = [ "ID", "Int" ].includes(gqlType) ? gqlType : this.isPrimaryKey ? "ID" : "Int";
  }
  get _supportsUnique() {
    return !0;
  }
  gqlOutputFields() {
    return [ `${this.path}: ${this.gqlType}` ];
  }
  gqlOutputFieldResolvers() {
    return {
      ["" + this.path]: item => item[this.path]
    };
  }
  gqlQueryInputFields() {
    return [ ...this.equalityInputFields(this.gqlType), ...this.orderingInputFields(this.gqlType), ...this.inInputFields(this.gqlType) ];
  }
  gqlUpdateInputFields() {
    return [ `${this.path}: ${this.gqlType}` ];
  }
  gqlCreateInputFields() {
    return [ `${this.path}: ${this.gqlType}` ];
  }
}

class KnexAutoIncrementInterface extends adapterKnex.KnexFieldAdapter {
  constructor() {
    super(...arguments), this.isUnique = void 0 === this.config.isUnique || !!this.config.isUnique, 
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }
  get isNotNullable() {
    return this._isNotNullable ? this._isNotNullable : this._isNotNullable = !(void 0 !== this.knexOptions.isNotNullable && !this.knexOptions.isNotNullable);
  }
  addToTableSchema(table) {
    if (this.field.isPrimaryKey) table.increments(this.path).notNullable(); else {
      const column = table.specificType(this.path, "serial");
      this.isUnique ? column.unique() : this.isIndexed && column.index(), this.isNotNullable && column.notNullable();
    }
  }
  addToForeignTableSchema(table, {path: path, isUnique: isUnique, isIndexed: isIndexed, isNotNullable: isNotNullable}) {
    if (!this.field.isPrimaryKey) throw `Can't create foreign key '${path}' on table "${table._tableName}"; '${this.path}' on list '${this.field.listKey}' as is not the primary key.`;
    const column = table.integer(path).unsigned();
    isUnique ? column.unique() : isIndexed && column.index(), isNotNullable && column.notNullable();
  }
  getQueryConditions(dbPath) {
    return _objectSpread(_objectSpread(_objectSpread({}, this.equalityConditions(dbPath)), this.orderingConditions(dbPath)), this.inConditions(dbPath));
  }
}

const AutoIncrement = {
  type: "AutoIncrement",
  implementation: AutoIncrementImplementation,
  views: {
    Controller: fields.Integer.views.Controller,
    Field: fields.Integer.views.Field,
    Filter: fields.Integer.views.Filter
  },
  adapters: {
    knex: KnexAutoIncrementInterface
  },
  primaryKeyDefaults: {
    knex: {
      getConfig: () => ({
        type: AutoIncrement
      })
    }
  }
};

exports.AutoIncrement = AutoIncrement;
