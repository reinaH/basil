"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var path = _interopDefault(require("path")), _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty")), fields = require("@keystonejs/fields"), adapterMongoose = require("@keystonejs/adapter-mongoose"), adapterKnex = require("@keystonejs/adapter-knex");

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

class MongoIdImplementation extends fields.Implementation {
  get _supportsUnique() {
    return !0;
  }
  gqlOutputFields() {
    return [ this.path + ": ID" ];
  }
  gqlOutputFieldResolvers() {
    return {
      ["" + this.path]: item => item[this.path]
    };
  }
  gqlQueryInputFields() {
    return [ ...this.equalityInputFields("ID"), ...this.inInputFields("ID") ];
  }
  gqlUpdateInputFields() {
    return [ this.path + ": ID" ];
  }
  gqlCreateInputFields() {
    return [ this.path + ": ID" ];
  }
}

const validator = a => !a || /^[0-9a-fA-F]{24}$/.test(a.toString()), normaliseValue = a => a ? a.toString().toLowerCase() : null;

class MongooseMongoIdInterface extends adapterMongoose.MongooseFieldAdapter {
  addToMongooseSchema(schema, mongoose) {
    if (this.field.isPrimaryKey) return;
    const schemaOptions = {
      type: mongoose.Schema.Types.ObjectId,
      validate: {
        validator: this.buildValidator(validator),
        message: "{VALUE} is not a valid Mongo ObjectId"
      }
    };
    schema.add({
      [this.field.isPrimaryKey ? "_id" : this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }
  setupHooks({addPreSaveHook: addPreSaveHook, addPostReadHook: addPostReadHook}) {
    this.field.isPrimaryKey && (addPreSaveHook(item => (item.id && (item._id = item.id, 
    delete item.id), item)), addPostReadHook(itemOrModel => {
      const item = itemOrModel && itemOrModel.toObject ? itemOrModel.toObject() : itemOrModel;
      return item && item._id && (item.id = item._id.toString(), delete item._id), item;
    }));
  }
  getQueryConditions(dbPath) {
    const mongoose = this.listAdapter.parentAdapter.mongoose;
    return _objectSpread(_objectSpread({}, this.equalityConditions(this.field.isPrimaryKey ? "_id" : dbPath, mongoose.Types.ObjectId)), this.inConditions(this.field.isPrimaryKey ? "_id" : dbPath, mongoose.Types.ObjectId));
  }
}

class KnexMongoIdInterface extends adapterKnex.KnexFieldAdapter {
  constructor() {
    super(...arguments), this.isUnique = !!this.config.isUnique, this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }
  addToTableSchema(table) {
    const column = table.string(this.path, 24);
    this.isUnique ? column.unique() : this.isIndexed && column.index(), this.isNotNullable && column.notNullable(), 
    this.defaultTo && column.defaultTo(this.defaultTo);
  }
  setupHooks({addPreSaveHook: addPreSaveHook, addPostReadHook: addPostReadHook}) {
    addPreSaveHook(item => {
      if (!(this.path in item)) return item;
      if (item[this.path]) {
        if ("string" != typeof item[this.path]) throw `Invalid MongoID value given for '${this.path}'`;
        item[this.path] = normaliseValue(item[this.path]);
      } else item[this.path] = null;
      return item;
    }), addPostReadHook(item => (item[this.path] && (item[this.path] = normaliseValue(item[this.path])), 
    item));
  }
  getQueryConditions(dbPath) {
    return _objectSpread(_objectSpread({}, this.equalityConditions(dbPath, normaliseValue)), this.inConditions(dbPath, normaliseValue));
  }
}

const pkgDir = path.dirname(require.resolve("@keystonejs/fields-mongoid/package.json")), MongoId = {
  type: "MongoId",
  implementation: MongoIdImplementation,
  views: {
    Controller: path.join(pkgDir, "views/Controller"),
    Field: fields.Text.views.Field,
    Filter: path.join(pkgDir, "views/Filter")
  },
  adapters: {
    knex: KnexMongoIdInterface,
    mongoose: MongooseMongoIdInterface
  },
  primaryKeyDefaults: {
    knex: {
      getConfig: () => {
        throw "The Uuid field type doesn't provide a default primary key field configuration for knex. You'll need to supply your own 'id' field for each list or use a different field type for your ids (eg '@keystonejs/fields-auto-increment').";
      }
    },
    mongoose: {
      getConfig: () => ({
        type: MongoId
      })
    }
  }
};

exports.MongoId = MongoId;
