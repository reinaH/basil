"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

var _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty")), _objectWithoutProperties = _interopDefault(require("@babel/runtime/helpers/objectWithoutProperties")), core = require("@emotion/core"), React = require("react"), React__default = _interopDefault(React), _extends = _interopDefault(require("@babel/runtime/helpers/extends")), client = require("@apollo/client"), Select = _interopDefault(require("@arch-ui/select")), reactSelect = require("react-select");

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

function useIntersectionObserver(cb, ref) {
  React.useEffect(() => {
    let observer = new IntersectionObserver(cb, {}), node = ref.current;
    if (null !== node) return observer.observe(node), () => observer.unobserve(node);
  });
}

require("intersection-observer");

const initialItemsToLoad = 10, subsequentItemsToLoad = 50, Relationship = React.forwardRef(({data: data, loading: loading, value: value, refList: refList, canRead: canRead, isMulti: isMulti, search: search, autoFocus: autoFocus, serverErrors: serverErrors, onChange: onChange, htmlID: htmlID, setSearch: setSearch, selectProps: selectProps, fetchMore: fetchMore, isDisabled: isDisabled}, ref) => {
  const options = data && data[refList.gqlNames.listQueryName] ? data[refList.gqlNames.listQueryName].map(val => ({
    value: val,
    label: val._label_
  })) : [], serverError = serverErrors && serverErrors.find(error => error instanceof Error && "AccessDeniedError" === error.name);
  let currentValue = null;
  const getOption = value => "string" == typeof value ? options.find(opt => opt.value.id === value) || {
    label: value,
    value: value
  } : {
    label: value._label_,
    value: value
  };
  null !== value && canRead && (isMulti ? currentValue = (Array.isArray(value) ? value : []).map(getOption) : value && (currentValue = getOption(value)));
  const count = data && data[refList.gqlNames.listQueryMetaName] ? data[refList.gqlNames.listQueryMetaName].count : 0, selectComponents = React.useMemo(() => ({
    MenuList: _ref => {
      let {children: children} = _ref, props = _objectWithoutProperties(_ref, [ "children" ]);
      const loadingRef = React.useRef(null), QUERY = client.gql`
            query RelationshipSelectMore($search: String!, $first: Int!, $skip: Int!) {
              ${refList.gqlNames.listQueryName}(search: $search, first: $first, skip: $skip) {
                _label_
                id
              }
            }
          `;
      return useIntersectionObserver(([{isIntersecting: isIntersecting}]) => {
        !props.isLoading && isIntersecting && props.options.length < count && fetchMore({
          query: QUERY,
          variables: {
            search: search,
            first: 50,
            skip: props.options.length
          },
          updateQuery: (prev, {fetchMoreResult: fetchMoreResult}) => fetchMoreResult ? _objectSpread(_objectSpread({}, prev), {}, {
            [refList.gqlNames.listQueryName]: [ ...prev[refList.gqlNames.listQueryName], ...fetchMoreResult[refList.gqlNames.listQueryName] ]
          }) : prev
        });
      }, loadingRef), core.jsx(reactSelect.components.MenuList, props, children, core.jsx("div", {
        css: {
          textAlign: "center"
        },
        ref: loadingRef
      }, props.options.length < count && core.jsx("span", {
        css: {
          padding: 8
        }
      }, "Loading...")));
    }
  }), [ count, refList.gqlNames.listQueryName ]);
  return core.jsx(Select, _extends({
    onInputChange: val => setSearch(val),
    isLoading: loading,
    autoFocus: autoFocus,
    isMulti: isMulti,
    components: selectComponents,
    getOptionValue: option => option.value.id,
    value: currentValue,
    placeholder: canRead ? void 0 : serverError && serverError.message,
    options: options,
    onChange: onChange,
    id: "react-select-" + htmlID,
    isClearable: !0,
    instanceId: htmlID,
    inputId: htmlID,
    innerRef: ref,
    menuPortalTarget: document.body,
    isDisabled: isDisabled
  }, selectProps));
}), RelationshipSelect = ({innerRef: innerRef, autoFocus: autoFocus, field: field, errors: serverErrors, renderContext: renderContext, htmlID: htmlID, onChange: onChange, isMulti: isMulti, value: value, isDisabled: isDisabled}) => {
  const [search, setSearch] = React.useState(""), refList = field.getRefList(), QUERY = client.gql`
    query RelationshipSelect($search: String!, $first: Int!, $skip: Int!) {
      ${refList.gqlNames.listQueryName}(search: $search, first: $first, skip: $skip) {
        _label_
        id
      }

      ${refList.gqlNames.listQueryMetaName}(search: $search) {
        count
      }
    }
  `, canRead = !serverErrors || serverErrors.every(error => !(error instanceof Error && "AccessDeniedError" === error.name)), selectProps = "dialog" === renderContext ? {
    menuShouldBlockScroll: !0
  } : null, {data: data, error: error, loading: loading, fetchMore: fetchMore} = client.useQuery(QUERY, {
    fetchPolicy: "network-only",
    variables: {
      search: search,
      first: 10,
      skip: 0
    }
  });
  return error ? (console.log("ERROR!!!", error), "Error") : core.jsx(Relationship, {
    data: data,
    loading: loading,
    value: value,
    refList: refList,
    canRead: canRead,
    isMulti: isMulti,
    search: search,
    autoFocus: autoFocus,
    serverErrors: serverErrors,
    onChange: onChange,
    htmlID: htmlID,
    setSearch: setSearch,
    selectProps: selectProps,
    fetchMore: fetchMore,
    ref: innerRef,
    isDisabled: isDisabled
  });
};

exports.RelationshipSelect = RelationshipSelect;
