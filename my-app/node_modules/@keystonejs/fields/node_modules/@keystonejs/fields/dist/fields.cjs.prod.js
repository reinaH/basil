"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty")), _objectWithoutProperties = _interopDefault(require("@babel/runtime/helpers/objectWithoutProperties")), inflection = _interopDefault(require("inflection")), accessControl = require("@keystonejs/access-control"), path = _interopDefault(require("path")), dateFns = require("date-fns"), adapterMongoose = require("@keystonejs/adapter-mongoose"), adapterKnex = require("@keystonejs/adapter-knex"), graphql = require("graphql"), language = require("graphql/language"), luxon = require("luxon"), mongoose = _interopDefault(require("mongoose")), dumbPasswords = _interopDefault(require("dumb-passwords")), groupBy = _interopDefault(require("lodash.groupby")), pSettle = _interopDefault(require("p-settle")), utils = require("@keystonejs/utils"), apolloErrors = require("apollo-errors"), serverSideGraphqlClient = require("@keystonejs/server-side-graphql-client"), slugify = _interopDefault(require("@sindresorhus/slugify")), cuid = _interopDefault(require("cuid"));

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

class Field {
  constructor(path, _ref, {getListByKey: getListByKey, listKey: listKey, listAdapter: listAdapter, fieldAdapterClass: fieldAdapterClass, defaultAccess: defaultAccess, schemaNames: schemaNames}) {
    let {hooks: hooks = {}, isRequired: isRequired, defaultValue: defaultValue, access: access, label: label, schemaDoc: schemaDoc, adminDoc: adminDoc, adminConfig: adminConfig} = _ref, config = _objectWithoutProperties(_ref, [ "hooks", "isRequired", "defaultValue", "access", "label", "schemaDoc", "adminDoc", "adminConfig" ]);
    if (this.path = path, this.isPrimaryKey = "id" === path, this.schemaDoc = schemaDoc, 
    this.adminDoc = adminDoc, this.adminConfig = adminConfig, this.config = config, 
    this.isRequired = !!isRequired, this.defaultValue = defaultValue, this.isOrderable = !1, 
    this.hooks = hooks, this.getListByKey = getListByKey, this.listKey = listKey, this.label = label || inflection.humanize(inflection.underscore(path)), 
    this.config.isUnique && !this._supportsUnique) throw new Error(`isUnique is not a supported option for field type ${this.constructor.name} (${this.path})`);
    this.adapter = listAdapter.newFieldAdapter(fieldAdapterClass, this.constructor.name, path, this, getListByKey, _objectSpread({}, config)), 
    this.isRelationship = !1, this.access = this.parseFieldAccess({
      schemaNames: schemaNames,
      listKey: listKey,
      fieldKey: path,
      defaultAccess: defaultAccess,
      access: access
    });
  }
  get _supportsUnique() {
    return !1;
  }
  parseFieldAccess(args) {
    return accessControl.parseFieldAccess(args);
  }
  gqlOutputFields() {
    return [];
  }
  gqlOutputFieldResolvers() {
    return {};
  }
  getGqlAuxTypes() {
    return [];
  }
  gqlAuxFieldResolvers() {
    return {};
  }
  getGqlAuxQueries() {
    return [];
  }
  gqlAuxQueryResolvers() {
    return {};
  }
  getGqlAuxMutations() {
    return [];
  }
  gqlAuxMutationResolvers() {
    return {};
  }
  async resolveInput({resolvedData: resolvedData}) {
    return resolvedData[this.path];
  }
  async validateInput() {}
  async beforeChange() {}
  async afterChange() {}
  async beforeDelete() {}
  async validateDelete() {}
  async afterDelete() {}
  gqlQueryInputFields() {
    return [];
  }
  equalityInputFields(type) {
    return [ `${this.path}: ${type}`, `${this.path}_not: ${type}` ];
  }
  equalityInputFieldsInsensitive(type) {
    return [ `${this.path}_i: ${type}`, `${this.path}_not_i: ${type}` ];
  }
  inInputFields(type) {
    return [ `${this.path}_in: [${type}]`, `${this.path}_not_in: [${type}]` ];
  }
  orderingInputFields(type) {
    return [ `${this.path}_lt: ${type}`, `${this.path}_lte: ${type}`, `${this.path}_gt: ${type}`, `${this.path}_gte: ${type}` ];
  }
  stringInputFields(type) {
    return [ `${this.path}_contains: ${type}`, `${this.path}_not_contains: ${type}`, `${this.path}_starts_with: ${type}`, `${this.path}_not_starts_with: ${type}`, `${this.path}_ends_with: ${type}`, `${this.path}_not_ends_with: ${type}` ];
  }
  stringInputFieldsInsensitive(type) {
    return [ `${this.path}_contains_i: ${type}`, `${this.path}_not_contains_i: ${type}`, `${this.path}_starts_with_i: ${type}`, `${this.path}_not_starts_with_i: ${type}`, `${this.path}_ends_with_i: ${type}`, `${this.path}_not_ends_with_i: ${type}` ];
  }
  gqlCreateInputFields() {
    return [];
  }
  gqlUpdateInputFields() {
    return [];
  }
  getAdminMeta({schemaName: schemaName}) {
    const schemaAccess = this.access[schemaName];
    return this.extendAdminMeta(_objectSpread(_objectSpread({
      label: this.label,
      path: this.path,
      type: this.constructor.name,
      isRequired: this.isRequired,
      isOrderable: this.isOrderable,
      defaultValue: "function" != typeof this.defaultValue ? this.defaultValue : void 0,
      isPrimaryKey: this.isPrimaryKey
    }, this.adminConfig), {}, {
      access: {
        create: !!schemaAccess.create,
        read: !!schemaAccess.read,
        update: !!schemaAccess.update
      },
      adminDoc: this.adminDoc
    }));
  }
  extendAdminMeta(meta) {
    return meta;
  }
  extendAdminViews(views) {
    return views;
  }
  getDefaultValue({context: context, originalInput: originalInput}) {
    if (void 0 !== this.defaultValue) return "function" == typeof this.defaultValue ? this.defaultValue({
      context: context,
      originalInput: originalInput
    }) : this.defaultValue;
  }
}

const pkgDir = path.dirname(require.resolve("@keystonejs/fields/package.json")), resolveView = pathname => path.join(pkgDir, pathname);

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

class CalendarDay extends Field {
  constructor(path, {format: format = "yyyy-MM-dd", dateFrom: dateFrom, dateTo: dateTo}) {
    if (super(...arguments), this.format = format, this._dateFrom = dateFrom, this._dateTo = dateTo, 
    this._dateFrom && (10 !== this._dateFrom.length || !dateFns.isValid(dateFns.parseISO(this._dateFrom)))) throw new Error(`Invalid value for option "dateFrom" of field '${this.listKey}.${path}': "${this._dateFrom}"`);
    if (this._dateTo && (10 !== this._dateTo.length || !dateFns.isValid(dateFns.parseISO(this._dateTo)))) throw new Error(`Invalid value for option "dateTo" of field '${this.listKey}.${path}': "${this._dateFrom}"`);
    if (this._dateTo && this._dateFrom && 1 === dateFns.compareAsc(dateFns.parseISO(this._dateFrom), dateFns.parseISO(this._dateTo))) throw new Error(`Invalid values for options "dateFrom", "dateTo" of field '${this.listKey}.${path}': "${dateFrom}" > "${dateTo}"`);
    this.isOrderable = !0;
  }
  get _supportsUnique() {
    return !0;
  }
  gqlOutputFields() {
    return [ this.path + ": String" ];
  }
  gqlQueryInputFields() {
    return [ ...this.equalityInputFields("String"), ...this.orderingInputFields("String"), ...this.inInputFields("String") ];
  }
  gqlUpdateInputFields() {
    return [ this.path + ": String" ];
  }
  gqlCreateInputFields() {
    return [ this.path + ": String" ];
  }
  extendAdminMeta(meta) {
    return _objectSpread$1(_objectSpread$1({}, meta), {}, {
      format: this.format,
      dateFrom: this._dateFrom,
      dateTo: this._dateTo
    });
  }
  async validateInput({resolvedData: resolvedData, addFieldValidationError: addFieldValidationError}) {
    const initialValue = resolvedData[this.path];
    if (null === initialValue) return !0;
    const parsedValue = dateFns.parseISO(resolvedData[this.path]);
    10 === initialValue.length && dateFns.isValid(parsedValue) || addFieldValidationError("Invalid CalendarDay value.", {
      value: resolvedData[this.path]
    }), parsedValue && (dateFns.parseISO(this._dateFrom) && 1 === dateFns.compareAsc(dateFns.parseISO(this._dateFrom), parsedValue) && addFieldValidationError(`Value is before earliest allowed date: ${this._dateFromString}.`, {
      value: resolvedData[this.path],
      dateFrom: this._dateFromString
    }), dateFns.parseISO(this._dateTo) && 1 === dateFns.compareDesc(dateFns.parseISO(this._dateTo), parsedValue) && addFieldValidationError(`Value is after latest allowed date: ${this._dateToString}.`, {
      value: resolvedData[this.path],
      dateTo: this._dateToString
    }));
  }
}

const CommonCalendarInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$1(_objectSpread$1(_objectSpread$1({}, this.equalityConditions(dbPath)), this.orderingConditions(dbPath)), this.inConditions(dbPath));
  }
};

class MongoCalendarDayInterface extends(CommonCalendarInterface(adapterMongoose.MongooseFieldAdapter)){
  addToMongooseSchema(schema) {
    const schemaOptions = {
      type: String,
      validate: {
        validator: this.buildValidator(a => "string" == typeof a && 10 === a.length && dateFns.parseISO(a)),
        message: "{VALUE} is not an ISO8601 date string (yyyy-MM-dd)"
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }
}

class KnexCalendarDayInterface extends(CommonCalendarInterface(adapterKnex.KnexFieldAdapter)){
  constructor() {
    super(...arguments), this.isUnique = !!this.config.isUnique, this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }
  addToTableSchema(table) {
    const column = table.date(this.path);
    this.isUnique ? column.unique() : this.isIndexed && column.index(), this.isNotNullable && column.notNullable(), 
    this.defaultTo && column.defaultTo(this.defaultTo);
  }
  setupHooks({addPostReadHook: addPostReadHook}) {
    addPostReadHook(item => (item[this.path] && (item[this.path] = dateFns.formatISO(item[this.path], {
      representation: "date"
    })), item));
  }
}

var index = {
  type: "CalendarDay",
  implementation: CalendarDay,
  views: {
    Controller: resolveView("types/CalendarDay/views/Controller"),
    Field: resolveView("types/CalendarDay/views/Field"),
    Filter: resolveView("types/CalendarDay/views/Filter"),
    Cell: resolveView("types/CalendarDay/views/Cell")
  },
  adapters: {
    mongoose: MongoCalendarDayInterface,
    knex: KnexCalendarDayInterface
  }
};

class Checkbox extends Field {
  constructor() {
    super(...arguments), this.isOrderable = !0;
  }
  get _supportsUnique() {
    return !1;
  }
  gqlOutputFields() {
    return [ this.path + ": Boolean" ];
  }
  gqlOutputFieldResolvers() {
    return {
      ["" + this.path]: item => item[this.path]
    };
  }
  gqlQueryInputFields() {
    return this.equalityInputFields("Boolean");
  }
  gqlUpdateInputFields() {
    return [ this.path + ": Boolean" ];
  }
  gqlCreateInputFields() {
    return [ this.path + ": Boolean" ];
  }
}

class MongoCheckboxInterface extends adapterMongoose.MongooseFieldAdapter {
  addToMongooseSchema(schema) {
    schema.add({
      [this.path]: this.mergeSchemaOptions({
        type: Boolean
      }, this.config)
    });
  }
  getQueryConditions(dbPath) {
    return this.equalityConditions(dbPath);
  }
}

class KnexCheckboxInterface extends adapterKnex.KnexFieldAdapter {
  constructor() {
    if (super(...arguments), this.config.isIndexed) throw `The Checkbox field type doesn't support indexes on Knex. Check the config for ${this.path} on the ${this.field.listKey} list`;
  }
  addToTableSchema(table) {
    const column = table.boolean(this.path);
    this.isNotNullable && column.notNullable(), void 0 !== this.defaultTo && column.defaultTo(this.defaultTo);
  }
  getQueryConditions(dbPath) {
    return this.equalityConditions(dbPath);
  }
}

var index$1 = {
  type: "Checkbox",
  implementation: Checkbox,
  views: {
    Controller: resolveView("types/Checkbox/views/Controller"),
    Field: resolveView("types/Checkbox/views/Field"),
    Filter: resolveView("types/Checkbox/views/Filter"),
    Cell: resolveView("types/Checkbox/views/Cell")
  },
  adapters: {
    mongoose: MongoCheckboxInterface,
    knex: KnexCheckboxInterface
  }
};

function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

class _DateTime extends Field {
  constructor(path, {format: format, yearRangeFrom: yearRangeFrom, yearRangeTo: yearRangeTo, yearPickerType: yearPickerType}) {
    super(...arguments), this.format = format, this.yearRangeFrom = yearRangeFrom, this.yearRangeTo = yearRangeTo, 
    this.yearPickerType = yearPickerType, this.isOrderable = !0;
  }
  get _supportsUnique() {
    return !0;
  }
  gqlOutputFields() {
    return [ this.path + ": DateTime" ];
  }
  gqlQueryInputFields() {
    return [ ...this.equalityInputFields("DateTime"), ...this.orderingInputFields("DateTime"), ...this.inInputFields("DateTime") ];
  }
  gqlUpdateInputFields() {
    return [ this.path + ": DateTime" ];
  }
  gqlCreateInputFields() {
    return [ this.path + ": DateTime" ];
  }
  getGqlAuxTypes() {
    return [ "scalar DateTime" ];
  }
  extendAdminMeta(meta) {
    return _objectSpread$2(_objectSpread$2({}, meta), {}, {
      format: this.format,
      yearRangeFrom: this.yearRangeFrom,
      yearRangeTo: this.yearRangeTo,
      yearPickerType: this.yearPickerType
    });
  }
  gqlAuxFieldResolvers() {
    return {
      DateTime: new graphql.GraphQLScalarType({
        name: "DateTime",
        description: "DateTime custom scalar represents an ISO 8601 datetime string",
        parseValue: value => value,
        serialize: value => value,
        parseLiteral: ast => ast.kind === language.Kind.STRING ? ast.value : null
      })
    };
  }
}

const toDate = s => s && luxon.DateTime.fromISO(s, {
  zone: "utc"
}).toJSDate(), CommonDateTimeInterface = superclass => class extends superclass {
  setupHooks({addPreSaveHook: addPreSaveHook, addPostReadHook: addPostReadHook}) {
    const field_path = this.path, utc_field = field_path + "_utc", offset_field = field_path + "_offset";
    addPreSaveHook(item => {
      if (!(field_path in item)) return item;
      const datetimeString = item[field_path];
      if (!datetimeString) return item[utc_field] = null, item[offset_field] = null, delete item[field_path], 
      item;
      if (!luxon.DateTime.fromISO(datetimeString, {
        zone: "utc"
      }).isValid) throw new Error("Validation failed: DateTime must be either `null` or a valid ISO 8601 string");
      return item[utc_field] = toDate(datetimeString), item[offset_field] = luxon.DateTime.fromISO(datetimeString, {
        setZone: !0
      }).toFormat("ZZ"), delete item[field_path], item;
    }), addPostReadHook(item => {
      if (!(utc_field in item) && !(offset_field in item)) return item;
      if (!item[utc_field] || !item[offset_field]) return item[field_path] = null, item;
      const datetimeString = luxon.DateTime.fromJSDate(item[utc_field], {
        zone: "utc"
      }).setZone(new luxon.FixedOffsetZone(luxon.DateTime.fromISO("1234-01-01T00:00:00" + item[offset_field], {
        setZone: !0
      }).offset)).toISO();
      return item[field_path] = datetimeString, item[utc_field] = void 0, item[offset_field] = void 0, 
      item;
    });
  }
  getQueryConditions(dbPath) {
    return _objectSpread$2(_objectSpread$2(_objectSpread$2({}, this.equalityConditions(dbPath, toDate)), this.orderingConditions(dbPath, toDate)), this.inConditions(dbPath, toDate));
  }
};

class MongoDateTimeInterface extends(CommonDateTimeInterface(adapterMongoose.MongooseFieldAdapter)){
  constructor() {
    super(...arguments), this.utcPath = this.path + "_utc", this.offsetPath = this.path + "_offset", 
    this.realKeys = [ this.utcPath, this.offsetPath ], this.dbPath = this.utcPath;
  }
  addToMongooseSchema(schema) {
    const {mongooseOptions: mongooseOptions} = this.config;
    schema.add({
      [this.path]: _objectSpread$2({
        type: String
      }, mongooseOptions),
      [this.utcPath]: this.mergeSchemaOptions({
        type: Date
      }, this.config),
      [this.offsetPath]: _objectSpread$2({
        type: String
      }, mongooseOptions)
    });
  }
  getMongoFieldName() {
    return this.path + "_utc";
  }
}

class KnexDateTimeInterface extends(CommonDateTimeInterface(adapterKnex.KnexFieldAdapter)){
  constructor() {
    super(...arguments), this.utcPath = this.path + "_utc", this.offsetPath = this.path + "_offset", 
    this.realKeys = [ this.utcPath, this.offsetPath ], this.sortKey = this.utcPath, 
    this.dbPath = this.utcPath, this.isUnique = !!this.config.isUnique, this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }
  addToTableSchema(table) {
    const utcColumn = table.timestamp(this.utcPath, {
      useTz: !1
    }), offsetColumn = table.text(this.offsetPath);
    this.isUnique ? table.unique([ this.utcPath, this.offsetPath ]) : this.isIndexed && table.index([ this.utcPath, this.offsetPath ]), 
    this.isNotNullable && (utcColumn.notNullable(), offsetColumn.notNullable()), this.defaultTo && (this.defaultTo.utc || this.defaultTo.offset) ? (this.defaultTo.utc && utcColumn.defaultTo(this.defaultTo.utc), 
    this.defaultTo.offset && offsetColumn.defaultTo(this.defaultTo.offset)) : this.defaultTo && utcColumn.defaultTo(this.defaultTo);
  }
}

var DateTime = {
  type: "DateTime",
  implementation: _DateTime,
  views: {
    Controller: resolveView("types/DateTime/views/Controller"),
    Field: resolveView("types/DateTime/views/Field"),
    Filter: resolveView("types/DateTime/views/Filter"),
    Cell: resolveView("types/DateTime/views/Cell")
  },
  adapters: {
    mongoose: MongoDateTimeInterface,
    knex: KnexDateTimeInterface
  }
};

function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$3(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

class DateTimeUtcImplementation extends Field {
  constructor() {
    super(...arguments), this.isOrderable = !0;
  }
  get _supportsUnique() {
    return !0;
  }
  gqlOutputFields() {
    return [ this.path + ": String" ];
  }
  gqlOutputFieldResolvers() {
    return {
      ["" + this.path]: item => item[this.path] && item[this.path].toISOString()
    };
  }
  gqlQueryInputFields() {
    return [ ...this.equalityInputFields("String"), ...this.orderingInputFields("String"), ...this.inInputFields("String") ];
  }
  gqlUpdateInputFields() {
    return [ this.path + ": String" ];
  }
  gqlCreateInputFields() {
    return [ this.path + ": String" ];
  }
  getGqlAuxTypes() {
    return [ "scalar String" ];
  }
  extendAdminMeta(meta) {
    return _objectSpread$3(_objectSpread$3({}, meta), {}, {
      format: "yyyy-MM-dd[T]HH:mm:ss.SSSxx"
    });
  }
}

const toDate$1 = str => {
  if (null === str) return null;
  if (!str.match(/([zZ]|[\+\-][0-9]+(\:[0-9]+)?)$/)) throw `Value supplied (${str}) is not a valid date time with offset.`;
  return luxon.DateTime.fromISO(str).toJSDate();
};

class MongoDateTimeUtcInterface extends adapterMongoose.MongooseFieldAdapter {
  addToMongooseSchema(schema) {
    schema.add({
      [this.path]: this.mergeSchemaOptions({
        type: Date
      }, this.config)
    });
  }
  getQueryConditions(dbPath) {
    return _objectSpread$3(_objectSpread$3(_objectSpread$3({}, this.equalityConditions(dbPath, toDate$1)), this.orderingConditions(dbPath, toDate$1)), this.inConditions(dbPath, toDate$1));
  }
}

class KnexDateTimeUtcInterface extends adapterKnex.KnexFieldAdapter {
  constructor() {
    super(...arguments), this.isUnique = !!this.config.isUnique, this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }
  addToTableSchema(table) {
    const column = table.timestamp(this.path, {
      useTz: !0,
      precision: 3
    });
    this.isUnique ? column.unique() : this.isIndexed && column.index(), this.isNotNullable && column.notNullable(), 
    this.defaultTo && column.defaultTo(this.defaultTo);
  }
  getQueryConditions(dbPath) {
    return _objectSpread$3(_objectSpread$3(_objectSpread$3({}, this.equalityConditions(dbPath, toDate$1)), this.orderingConditions(dbPath, toDate$1)), this.inConditions(dbPath, toDate$1));
  }
}

var index$2 = {
  type: "DateTimeUtc",
  implementation: DateTimeUtcImplementation,
  views: {
    Controller: DateTime.views.Controller,
    Field: DateTime.views.Field,
    Filter: DateTime.views.Filter,
    Cell: DateTime.views.Cell
  },
  adapters: {
    mongoose: MongoDateTimeUtcInterface,
    knex: KnexDateTimeUtcInterface
  }
};

function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$4(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

class Decimal extends Field {
  constructor(path, {symbol: symbol}) {
    super(...arguments), this.symbol = symbol, this.isOrderable = !0;
  }
  get _supportsUnique() {
    return !0;
  }
  gqlOutputFields() {
    return [ this.path + ": String" ];
  }
  gqlOutputFieldResolvers() {
    return {
      ["" + this.path]: item => item[this.path]
    };
  }
  gqlQueryInputFields() {
    return [ ...this.equalityInputFields("String"), ...this.orderingInputFields("String"), ...this.inInputFields("String") ];
  }
  gqlUpdateInputFields() {
    return [ this.path + ": String" ];
  }
  gqlCreateInputFields() {
    return [ this.path + ": String" ];
  }
  extendAdminMeta(meta) {
    return _objectSpread$4(_objectSpread$4({}, meta), {}, {
      symbol: this.symbol
    });
  }
}

class MongoDecimalInterface extends adapterMongoose.MongooseFieldAdapter {
  addToMongooseSchema(schema) {
    const schemaOptions = {
      type: mongoose.Decimal128,
      validate: {
        validator: this.buildValidator(a => "object" == typeof a && /^-?\d*\.?\d*$/.test(a)),
        message: "{VALUE} is not a Decimal value"
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }
  setupHooks({addPreSaveHook: addPreSaveHook, addPostReadHook: addPostReadHook}) {
    addPreSaveHook(item => {
      if (!(this.path in item)) return item;
      if (item[this.path]) {
        if ("string" != typeof item[this.path]) throw `Invalid Decimal value given for '${this.path}'`;
        item[this.path] = mongoose.Types.Decimal128.fromString(item[this.path]);
      } else item[this.path] = null;
      return item;
    }), addPostReadHook(item => (item[this.path] && (item[this.path] = item[this.path].toString()), 
    item));
  }
  getQueryConditions(dbPath) {
    return _objectSpread$4(_objectSpread$4(_objectSpread$4({}, this.equalityConditions(dbPath, mongoose.Types.Decimal128.fromString)), this.orderingConditions(dbPath, mongoose.Types.Decimal128.fromString)), this.inConditions(dbPath, mongoose.Types.Decimal128.fromString));
  }
}

class KnexDecimalInterface extends adapterKnex.KnexFieldAdapter {
  constructor() {
    super(...arguments), this.isUnique = !!this.config.isUnique, this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
    const {precision: precision, scale: scale} = this.knexOptions;
    if (this.precision = null === precision ? null : parseInt(precision) || 18, this.scale = null === scale ? null : (this.precision, 
    parseInt(scale) || 4), null !== this.scale && null !== this.precision && this.scale > this.precision) throw `The scale configured for Decimal field '${this.path}' (${this.scale}) must not be larger than the field's precision (${this.precision})`;
  }
  addToTableSchema(table) {
    const column = table.decimal(this.path, this.precision, this.scale);
    this.isUnique ? column.unique() : this.isIndexed && column.index(), this.isNotNullable && column.notNullable(), 
    void 0 !== this.defaultTo && column.defaultTo(this.defaultTo);
  }
  getQueryConditions(dbPath) {
    return _objectSpread$4(_objectSpread$4(_objectSpread$4({}, this.equalityConditions(dbPath)), this.orderingConditions(dbPath)), this.inConditions(dbPath));
  }
}

var index$3 = {
  type: "Decimal",
  implementation: Decimal,
  views: {
    Controller: resolveView("types/Decimal/views/Controller"),
    Field: resolveView("types/Decimal/views/Field"),
    Filter: resolveView("types/Decimal/views/Filter")
  },
  adapters: {
    mongoose: MongoDecimalInterface,
    knex: KnexDecimalInterface
  }
};

function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$5(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

mongoose.set("objectIdGetter", !1);

class File extends Field {
  constructor(path, {adapter: adapter}) {
    if (super(...arguments), this.graphQLOutputType = "File", this.fileAdapter = adapter, 
    !this.fileAdapter) throw new Error("No file adapter provided for File field.");
  }
  get _supportsUnique() {
    return !1;
  }
  gqlOutputFields() {
    return [ `${this.path}: ${this.graphQLOutputType}` ];
  }
  gqlQueryInputFields() {
    return [ ...this.equalityInputFields("String"), ...this.stringInputFields("String"), ...this.inInputFields("String") ];
  }
  getFileUploadType() {
    return "Upload";
  }
  getGqlAuxTypes() {
    return [ `\n      type ${this.graphQLOutputType} {\n        id: ID\n        path: String\n        filename: String\n        originalFilename: String\n        mimetype: String\n        encoding: String\n        publicUrl: String\n      }\n    ` ];
  }
  gqlOutputFieldResolvers() {
    return {
      [this.path]: item => {
        const itemValues = item[this.path];
        return itemValues ? _objectSpread$5({
          publicUrl: this.fileAdapter.publicUrl(itemValues)
        }, itemValues) : null;
      }
    };
  }
  async resolveInput({resolvedData: resolvedData, existingItem: existingItem}) {
    const previousData = existingItem && existingItem[this.path], uploadData = resolvedData[this.path];
    if (void 0 === uploadData) return;
    if (null === uploadData) return null;
    const {createReadStream: createReadStream, filename: originalFilename, mimetype: mimetype, encoding: encoding} = await uploadData, stream = createReadStream();
    if (!stream && previousData) return previousData;
    const newId = new mongoose.Types.ObjectId, {id: id, filename: filename, _meta: _meta} = await this.fileAdapter.save({
      stream: stream,
      filename: originalFilename,
      mimetype: mimetype,
      encoding: encoding,
      id: newId
    });
    return {
      id: id,
      filename: filename,
      originalFilename: originalFilename,
      mimetype: mimetype,
      encoding: encoding,
      _meta: _meta
    };
  }
  gqlUpdateInputFields() {
    return [ `${this.path}: ${this.getFileUploadType()}` ];
  }
  gqlCreateInputFields() {
    return [ `${this.path}: ${this.getFileUploadType()}` ];
  }
}

const CommonFileInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$5(_objectSpread$5(_objectSpread$5({}, this.equalityConditions(dbPath)), this.stringConditions(dbPath)), this.inConditions(dbPath));
  }
};

class MongoFileInterface extends(CommonFileInterface(adapterMongoose.MongooseFieldAdapter)){
  addToMongooseSchema(schema) {
    const schemaOptions = {
      type: {
        id: mongoose.Types.ObjectId,
        path: String,
        filename: String,
        originalFilename: String,
        mimetype: String,
        encoding: String,
        _meta: Object
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }
}

class KnexFileInterface extends(CommonFileInterface(adapterKnex.KnexFieldAdapter)){
  constructor() {
    if (super(...arguments), this.config.isIndexed) throw `The File field type doesn't support indexes on Knex. Check the config for ${this.path} on the ${this.field.listKey} list`;
  }
  addToTableSchema(table) {
    const column = table.jsonb(this.path);
    this.isNotNullable && column.notNullable(), this.defaultTo && column.defaultTo(this.defaultTo);
  }
}

var index$4 = {
  type: "File",
  implementation: File,
  views: {
    Controller: resolveView("types/File/views/Controller"),
    Field: resolveView("types/File/views/Field"),
    Cell: resolveView("types/File/views/Cell")
  },
  adapters: {
    mongoose: MongoFileInterface,
    knex: KnexFileInterface
  }
};

function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$6(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

class Float extends Field {
  constructor() {
    super(...arguments), this.isOrderable = !0;
  }
  get _supportsUnique() {
    return !0;
  }
  gqlOutputFields() {
    return [ this.path + ": Float" ];
  }
  gqlOutputFieldResolvers() {
    return {
      ["" + this.path]: item => item[this.path]
    };
  }
  gqlQueryInputFields() {
    return [ ...this.equalityInputFields("Float"), ...this.orderingInputFields("Float"), ...this.inInputFields("Float") ];
  }
  gqlUpdateInputFields() {
    return [ this.path + ": Float" ];
  }
  gqlCreateInputFields() {
    return [ this.path + ": Float" ];
  }
}

const CommonFloatInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.equalityConditions(dbPath)), this.orderingConditions(dbPath)), this.inConditions(dbPath));
  }
};

class MongoFloatInterface extends(CommonFloatInterface(adapterMongoose.MongooseFieldAdapter)){
  addToMongooseSchema(schema) {
    schema.add({
      [this.path]: this.mergeSchemaOptions({
        type: Number
      }, this.config)
    });
  }
}

class KnexFloatInterface extends(CommonFloatInterface(adapterKnex.KnexFieldAdapter)){
  constructor() {
    super(...arguments), this.isUnique = !!this.config.isUnique, this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }
  addToTableSchema(table) {
    const column = table.float(this.path);
    this.isUnique ? column.unique() : this.isIndexed && column.index(), this.isNotNullable && column.notNullable(), 
    void 0 !== this.defaultTo && column.defaultTo(this.defaultTo);
  }
}

var index$5 = {
  type: "Float",
  implementation: Float,
  views: {
    Controller: resolveView("types/Float/views/Controller"),
    Field: resolveView("types/Float/views/Field"),
    Filter: resolveView("types/Float/views/Filter")
  },
  adapters: {
    mongoose: MongoFloatInterface,
    knex: KnexFloatInterface
  }
};

function ownKeys$7(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$7(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

class Integer extends Field {
  constructor() {
    super(...arguments), this.isOrderable = !0;
  }
  get _supportsUnique() {
    return !0;
  }
  gqlOutputFields() {
    return [ this.path + ": Int" ];
  }
  gqlOutputFieldResolvers() {
    return {
      ["" + this.path]: item => item[this.path]
    };
  }
  gqlQueryInputFields() {
    return [ ...this.equalityInputFields("Int"), ...this.orderingInputFields("Int"), ...this.inInputFields("Int") ];
  }
  gqlUpdateInputFields() {
    return [ this.path + ": Int" ];
  }
  gqlCreateInputFields() {
    return [ this.path + ": Int" ];
  }
}

const CommonIntegerInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$7(_objectSpread$7(_objectSpread$7({}, this.equalityConditions(dbPath)), this.orderingConditions(dbPath)), this.inConditions(dbPath));
  }
};

class MongoIntegerInterface extends(CommonIntegerInterface(adapterMongoose.MongooseFieldAdapter)){
  addToMongooseSchema(schema) {
    const schemaOptions = {
      type: Number,
      validate: {
        validator: this.buildValidator(a => "number" == typeof a && Number.isInteger(a)),
        message: "{VALUE} is not an integer value"
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }
}

class KnexIntegerInterface extends(CommonIntegerInterface(adapterKnex.KnexFieldAdapter)){
  constructor() {
    super(...arguments), this.isUnique = !!this.config.isUnique, this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }
  addToTableSchema(table) {
    const column = table.integer(this.path);
    this.isUnique ? column.unique() : this.isIndexed && column.index(), this.isNotNullable && column.notNullable(), 
    void 0 !== this.defaultTo && column.defaultTo(this.defaultTo);
  }
}

var index$6 = {
  type: "Integer",
  implementation: Integer,
  views: {
    Controller: resolveView("types/Integer/views/Controller"),
    Field: resolveView("types/Integer/views/Field"),
    Filter: resolveView("types/Integer/views/Filter")
  },
  adapters: {
    mongoose: MongoIntegerInterface,
    knex: KnexIntegerInterface
  }
};

function ownKeys$8(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$8(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

const bcryptHashRegex = /^\$2[aby]?\$\d{1,2}\$[.\/A-Za-z0-9]{53}$/;

class Password extends Field {
  constructor(path, {rejectCommon: rejectCommon, minLength: minLength, workFactor: workFactor, useCompiledBcrypt: useCompiledBcrypt}) {
    super(...arguments), this.bcrypt = require(useCompiledBcrypt ? "bcrypt" : "bcryptjs"), 
    this.rejectCommon = !!rejectCommon, this.minLength = Math.max(Number.parseInt(minLength) || 8, 1), 
    this.workFactor = Math.min(Math.max(Number.parseInt(workFactor) || 10, 4), 31), 
    this.workFactor < 6 && console.warn(`The workFactor for ${this.listKey}.${this.path} is very low! This will cause weak hashes!`);
  }
  get _supportsUnique() {
    return !1;
  }
  gqlOutputFields() {
    return [ this.path + "_is_set: Boolean" ];
  }
  gqlOutputFieldResolvers() {
    return {
      [this.path + "_is_set"]: item => {
        const val = item[this.path];
        return bcryptHashRegex.test(val);
      }
    };
  }
  gqlQueryInputFields() {
    return [ this.path + "_is_set: Boolean" ];
  }
  gqlUpdateInputFields() {
    return [ this.path + ": String" ];
  }
  gqlCreateInputFields() {
    return [ this.path + ": String" ];
  }
  compare(candidate, hash, callback) {
    return this.bcrypt.compare(candidate, hash, callback);
  }
  compareSync(candidate, hash) {
    return this.bcrypt.compareSync(candidate, hash);
  }
  generateHash(plaintext, callback) {
    return this.validateNewPassword(plaintext), this.bcrypt.hash(plaintext, this.workFactor, callback);
  }
  generateHashSync(plaintext) {
    return this.validateNewPassword(plaintext), this.bcrypt.hashSync(plaintext, this.workFactor);
  }
  extendAdminMeta(meta) {
    const {minLength: minLength} = this;
    return _objectSpread$8(_objectSpread$8({}, meta), {}, {
      minLength: minLength
    });
  }
  validateNewPassword(password) {
    if (this.rejectCommon && dumbPasswords.check(password)) throw new Error(`[password:rejectCommon:${this.listKey}:${this.path}] Common and frequently-used passwords are not allowed.`);
    if (String(password).length < this.minLength) throw new Error(`[password:minLength:${this.listKey}:${this.path}] Value must be at least ${this.minLength} characters long.`);
  }
}

const CommonPasswordInterface = superclass => class extends superclass {
  setupHooks({addPreSaveHook: addPreSaveHook}) {
    addPreSaveHook(async item => {
      const path = this.field.path, plaintext = item[path];
      if (!(path in item)) return item;
      if (plaintext) {
        if ("string" != typeof plaintext) throw `Invalid Password value given for '${path}'`;
        item[path] = await this.field.generateHash(plaintext);
      } else item[path] = null;
      return item;
    });
  }
};

class MongoPasswordInterface extends(CommonPasswordInterface(adapterMongoose.MongooseFieldAdapter)){
  addToMongooseSchema(schema) {
    schema.add({
      [this.path]: this.mergeSchemaOptions({
        type: String
      }, this.config)
    });
  }
  getQueryConditions(dbPath) {
    return {
      [this.path + "_is_set"]: value => ({
        [dbPath]: value ? {
          $regex: bcryptHashRegex
        } : {
          $not: bcryptHashRegex
        }
      })
    };
  }
}

class KnexPasswordInterface extends(CommonPasswordInterface(adapterKnex.KnexFieldAdapter)){
  constructor() {
    if (super(...arguments), this.config.isIndexed) throw `The Password field type doesn't support indexes on Knex. Check the config for ${this.path} on the ${this.field.listKey} list`;
    if (this.config.defaultTo) throw `The Password field type doesn't support the Knex 'defaultTo' config. Check the config for ${this.path} on the ${this.field.listKey} list`;
  }
  addToTableSchema(table) {
    const column = table.string(this.path, 60);
    this.isNotNullable && column.notNullable();
  }
  getQueryConditions(dbPath) {
    return {
      [this.path + "_is_set"]: value => b => value ? b.where(dbPath, "~", bcryptHashRegex.source) : b.where(dbPath, "!~", bcryptHashRegex.source).orWhereNull(dbPath)
    };
  }
}

var index$7 = {
  type: "Password",
  implementation: Password,
  views: {
    Controller: resolveView("types/Password/views/Controller"),
    Field: resolveView("types/Password/views/Field"),
    Filter: resolveView("types/Password/views/Filter"),
    Cell: resolveView("types/Password/views/Cell")
  },
  adapters: {
    mongoose: MongoPasswordInterface,
    knex: KnexPasswordInterface
  }
};

const ParameterError = apolloErrors.createError("ParameterError", {
  message: "Incorrect parameters supplied",
  options: {
    showPath: !0
  }
});

function ownKeys$9(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread$9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$9(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

const NESTED_MUTATIONS = [ "create", "connect", "disconnect", "disconnectAll" ], throwWithErrors = (message, meta) => {
  const error = new Error(message);
  throw Object.assign(error, meta);
};

function validateInput({input: input, target: target, many: many}) {
  let validInputMutations = utils.intersection(Object.keys(input), NESTED_MUTATIONS);
  if (validInputMutations = many ? validInputMutations.filter(mutation => "disconnectAll" === mutation || Array.isArray(input[mutation])) : validInputMutations.filter(mutation => "disconnectAll" === mutation || Object.keys(input[mutation]).length), 
  !validInputMutations.length) throw new ParameterError({
    message: `Must provide a nested mutation (${NESTED_MUTATIONS.join(", ")}) when mutating ${target}`
  });
  if (!many && validInputMutations.includes("create") && validInputMutations.includes("connect")) throw new ParameterError({
    message: "Can only provide one of 'connect' or 'create' when mutating " + target
  });
  return validInputMutations;
}

const cleanAndValidateInput = ({input: input, many: many, localField: localField, target: target}) => {
  try {
    return utils.pick(input, validateInput({
      input: input,
      target: target,
      many: many
    }));
  } catch (error) {
    const message = "Nested mutation operation invalid for " + target;
    error.path = [ "<validate>" ], throwWithErrors(message, {
      errors: [ error ],
      path: [ localField.path ]
    });
  }
}, _runActions = async (action, targets, path) => {
  const results = await pSettle((targets || []).map(action)), errors = results.map((settleInfo, index) => _objectSpread$9(_objectSpread$9({}, settleInfo), {}, {
    index: index
  })).filter(({isRejected: isRejected}) => isRejected).map(({reason: reason, index: index}) => (reason.path = [ ...path, index ], 
  reason));
  return [ errors.length ? [] : results.map(({value: value}) => value), errors ];
};

async function resolveNestedMany({input: input, currentValue: currentValue, refList: refList, context: context, localField: localField, target: target, mutationState: mutationState}) {
  let disconnectIds = [];
  if (input.disconnectAll) disconnectIds = [ ...currentValue ]; else if (input.disconnect) {
    const {withId: withId, withoutId: withoutId} = groupBy(input.disconnect, ({id: id}) => id ? "withId" : "withoutId");
    disconnectIds = (withId || []).map(({id: id}) => id);
    const action = where => refList.itemQuery(where, context, refList.gqlNames.itemQueryName), disconnectItems = (await pSettle((withoutId || []).map(action))).filter(({isFulfilled: isFulfilled}) => isFulfilled).map(({value: value}) => value).filter(itemToDisconnect => itemToDisconnect);
    disconnectIds.push(...disconnectItems.map(({id: id}) => id));
  }
  let connectedIds = [], createdIds = [];
  if (input.connect || input.create) {
    const [connectedItems, connectErrors] = await _runActions(where => refList.itemQuery({
      where: where
    }, context, refList.gqlNames.itemQueryName), input.connect, [ "connect" ]), [createdItems, createErrors] = await _runActions(data => refList.createMutation(data, context, mutationState), input.create, [ "create" ]), allErrors = [ ...connectErrors, ...createErrors ];
    if (allErrors.length) {
      const message = `Unable to create and/or connect ${allErrors.length} ${target}`;
      throwWithErrors(message, {
        errors: allErrors,
        path: [ localField.path ]
      });
    }
    connectedIds = connectedItems.map(item => item && item.id ? item.id : null), createdIds = createdItems.map(item => item && item.id ? item.id : null);
  }
  return {
    disconnect: disconnectIds,
    connect: connectedIds,
    create: createdIds
  };
}

async function resolveNestedSingle({input: input, currentValue: currentValue, localField: localField, refList: refList, context: context, target: target, mutationState: mutationState}) {
  let operation, method, result_ = {};
  if ((input.disconnect || input.disconnectAll) && currentValue) {
    let idToDisconnect;
    if (input.disconnectAll) idToDisconnect = currentValue; else if (input.disconnect.id) idToDisconnect = input.disconnect.id; else try {
      idToDisconnect = (await refList.itemQuery({
        where: input.disconnect
      }, context, refList.gqlNames.itemQueryName)).id.toString();
    } catch (error) {}
    currentValue === idToDisconnect && (result_.disconnect = [ idToDisconnect ]);
  }
  if (input.connect ? (operation = "connect", method = () => refList.itemQuery({
    where: input.connect
  }, context, refList.gqlNames.itemQueryName)) : input.create && (operation = "create", 
  method = () => refList.createMutation(input.create, context, mutationState)), operation) {
    let item;
    try {
      item = await method();
    } catch (error) {
      const message = `Unable to ${operation} a ${target}`;
      error.path = [ operation ], throwWithErrors(message, {
        errors: [ error ],
        path: [ localField.path ]
      });
    }
    item && (result_[operation] = [ item.id ]);
  }
  return result_;
}

async function resolveNested({input: input, currentValue: currentValue, many: many, listInfo: listInfo, context: context, mutationState: mutationState}) {
  const localList = listInfo.local.list, localField = listInfo.local.field, refList = listInfo.foreign.list, target = `${localList.key}.${localField.path}<${refList.key}>`, args = {
    currentValue: currentValue,
    refList: refList,
    input: cleanAndValidateInput({
      input: input,
      many: many,
      localField: localField,
      target: target
    }),
    context: context,
    localField: localField,
    target: target,
    mutationState: mutationState
  };
  return await (many ? resolveNestedMany(args) : resolveNestedSingle(args));
}

function ownKeys$a(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread$a(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$a(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$a(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

class Relationship extends Field {
  constructor(path, {ref: ref, many: many, withMeta: withMeta}) {
    super(...arguments);
    const [refListKey, refFieldPath] = ref.split(".");
    this.refListKey = refListKey, this.refFieldPath = refFieldPath, this.isOrderable = !0, 
    this.isRelationship = !0, this.many = many, this.withMeta = void 0 === withMeta || withMeta;
  }
  get _supportsUnique() {
    return !0;
  }
  tryResolveRefList() {
    const {listKey: listKey, path: path, refListKey: refListKey, refFieldPath: refFieldPath} = this, refList = this.getListByKey(refListKey);
    if (!refList) throw new Error(`Unable to resolve related list '${refListKey}' from ${listKey}.${path}`);
    let refField;
    if (refFieldPath && (refField = refList.getFieldByPath(refFieldPath), !refField)) throw new Error(`Unable to resolve two way relationship field '${refListKey}.${refFieldPath}' from ${listKey}.${path}`);
    return {
      refList: refList,
      refField: refField
    };
  }
  gqlOutputFields({schemaName: schemaName}) {
    const {refList: refList} = this.tryResolveRefList();
    if (!refList.access[schemaName].read) return [];
    if (this.many) {
      const filterArgs = refList.getGraphqlFilterFragment().join("\n");
      return [ `${this.path}(${filterArgs}): [${refList.gqlNames.outputTypeName}!]!`, this.withMeta ? `_${this.path}Meta(${filterArgs}): _QueryMeta` : "" ];
    }
    return [ `${this.path}: ${refList.gqlNames.outputTypeName}` ];
  }
  extendAdminMeta(meta) {
    const {refListKey: ref, refFieldPath: refFieldPath, many: many} = this;
    return _objectSpread$a(_objectSpread$a({}, meta), {}, {
      ref: ref,
      refFieldPath: refFieldPath,
      many: many
    });
  }
  gqlQueryInputFields({schemaName: schemaName}) {
    const {refList: refList} = this.tryResolveRefList();
    return refList.access[schemaName].read ? this.many ? [ `""" condition must be true for all nodes """\n        ${this.path}_every: ${refList.gqlNames.whereInputName}`, `""" condition must be true for at least 1 node """\n        ${this.path}_some: ${refList.gqlNames.whereInputName}`, `""" condition must be false for all nodes """\n        ${this.path}_none: ${refList.gqlNames.whereInputName}` ] : [ `${this.path}: ${refList.gqlNames.whereInputName}`, this.path + "_is_null: Boolean" ] : [];
  }
  gqlOutputFieldResolvers({schemaName: schemaName}) {
    const {refList: refList} = this.tryResolveRefList();
    return refList.access[schemaName].read ? this.many ? _objectSpread$a({
      [this.path]: (item, args, context, info) => refList.listQuery(args, context, info.fieldName, info, {
        fromList: this.getListByKey(this.listKey),
        fromId: item.id,
        fromField: this.path
      })
    }, this.withMeta && {
      [`_${this.path}Meta`]: (item, args, context, info) => refList.listQueryMeta(args, context, info.fieldName, info, {
        fromList: this.getListByKey(this.listKey),
        fromId: item.id,
        fromField: this.path
      })
    }) : {
      [this.path]: (item, _, context, info) => {
        if (!item[this.path]) return null;
        const filteredQueryArgs = {
          where: {
            id: item[this.path].toString()
          }
        };
        return refList.listQuery(filteredQueryArgs, context, refList.gqlNames.listQueryName, info).then(items => items && items.length ? items[0] : null);
      }
    } : [];
  }
  async resolveNestedOperations(operations, item, context, getItem, mutationState) {
    const {refList: refList, refField: refField} = this.tryResolveRefList(), listInfo = {
      local: {
        list: this.getListByKey(this.listKey),
        field: this
      },
      foreign: {
        list: refList,
        field: refField
      }
    };
    if (!operations && (!this.isRequired || refField && this.getListByKey(refField.refListKey) === listInfo.local.list)) return Promise.resolve({
      create: [],
      connect: [],
      disconnect: []
    });
    let currentValue;
    if (this.many) {
      const info = {
        fieldName: this.path
      };
      currentValue = item ? await refList.listQuery({}, _objectSpread$a(_objectSpread$a({}, context), {}, {
        getListAccessControlForUser: () => !0
      }), info.fieldName, info, {
        fromList: this.getListByKey(this.listKey),
        fromId: item.id,
        fromField: this.path
      }) : [], currentValue = currentValue.map(({id: id}) => id.toString());
    } else currentValue = item && item[this.path], currentValue = currentValue && currentValue.toString();
    const {create: create = [], connect: connect = [], disconnect: disconnect = []} = await resolveNested({
      input: operations,
      currentValue: currentValue,
      listInfo: listInfo,
      many: this.many,
      context: context,
      mutationState: mutationState
    });
    return {
      create: create,
      connect: connect,
      disconnect: disconnect,
      currentValue: currentValue
    };
  }
  getGqlAuxTypes({schemaName: schemaName}) {
    const {refList: refList} = this.tryResolveRefList(), schemaAccess = refList.access[schemaName];
    if (schemaAccess.read || schemaAccess.create || schemaAccess.update || schemaAccess.delete || schemaAccess.auth) {
      const operations = [];
      return this.many ? (refList.access[schemaName].create && operations.push(`# Provide data to create a set of new ${refList.key}. Will also connect.\n          create: [${refList.gqlNames.createInputName}]`), 
      operations.push(`# Provide a filter to link to a set of existing ${refList.key}.\n          connect: [${refList.gqlNames.whereUniqueInputName}]`, `# Provide a filter to remove to a set of existing ${refList.key}.\n          disconnect: [${refList.gqlNames.whereUniqueInputName}]`, `# Remove all ${refList.key} in this list.\n          disconnectAll: Boolean`), 
      [ `input ${refList.gqlNames.relateToManyInputName} {\n          ${operations.join("\n")}\n        }\n      ` ]) : (schemaAccess.create && operations.push(`# Provide data to create a new ${refList.key}.\n        create: ${refList.gqlNames.createInputName}`), 
      operations.push(`# Provide a filter to link to an existing ${refList.key}.\n        connect: ${refList.gqlNames.whereUniqueInputName}`, `# Provide a filter to remove to an existing ${refList.key}.\n        disconnect: ${refList.gqlNames.whereUniqueInputName}`, `# Remove the existing ${refList.key} (if any).\n        disconnectAll: Boolean`), 
      [ `input ${refList.gqlNames.relateToOneInputName} {\n          ${operations.join("\n")}\n        }\n      ` ]);
    }
    return [];
  }
  gqlUpdateInputFields({schemaName: schemaName}) {
    const {refList: refList} = this.tryResolveRefList(), schemaAccess = refList.access[schemaName];
    return schemaAccess.read || schemaAccess.create || schemaAccess.update || schemaAccess.delete || schemaAccess.auth ? this.many ? [ `${this.path}: ${refList.gqlNames.relateToManyInputName}` ] : [ `${this.path}: ${refList.gqlNames.relateToOneInputName}` ] : [];
  }
  gqlCreateInputFields({schemaName: schemaName}) {
    return this.gqlUpdateInputFields({
      schemaName: schemaName
    });
  }
}

class MongoRelationshipInterface extends adapterMongoose.MongooseFieldAdapter {
  constructor(...args) {
    super(...args);
    const [refListKey, refFieldPath] = this.config.ref.split(".");
    this.refListKey = refListKey, this.refFieldPath = refFieldPath, this.isRelationship = !0;
  }
  addToMongooseSchema(schema, _mongoose, rels) {
    if (!this.field.many) {
      const {right: right, cardinality: cardinality} = rels.find(({left: left, right: right}) => left.adapter === this || right && right.adapter === this);
      if ("1:1" === cardinality && right && right.adapter === this) return;
      const {refListKey: refListKey, config: config} = this, type = mongoose.Types.ObjectId;
      schema.add({
        [this.path]: this.mergeSchemaOptions({
          type: type,
          ref: refListKey
        }, config)
      });
    }
  }
  getQueryConditions(dbPath) {
    return {
      [this.path + "_is_null"]: value => ({
        [dbPath]: value ? {
          $not: {
            $exists: !0,
            $ne: null
          }
        } : {
          $exists: !0,
          $ne: null
        }
      })
    };
  }
}

class KnexRelationshipInterface extends adapterKnex.KnexFieldAdapter {
  constructor() {
    super(...arguments), this.isRelationship = !0, this.isUnique = void 0 !== this.config.isUnique && !!this.config.isUnique, 
    this.isIndexed = void 0 === this.config.isIndexed ? !this.config.isUnique : !!this.config.isIndexed;
    const [refListKey, refFieldPath] = this.config.ref.split(".");
    this.refListKey = refListKey, this.refFieldPath = refFieldPath;
  }
  get isNotNullable() {
    return this._isNotNullable ? this._isNotNullable : this._isNotNullable = !(void 0 === this.knexOptions.isNotNullable || !this.knexOptions.isNotNullable);
  }
  addToTableSchema(table, rels) {
    if (!this.field.many) {
      const {right: right, cardinality: cardinality} = rels.find(({left: left, right: right}) => left.adapter === this || right && right.adapter === this);
      if ("1:1" === cardinality && right && right.adapter === this) return;
      const refId = this.getListByKey(this.refListKey).getPrimaryKey(), foreignKeyConfig = {
        path: this.path,
        isUnique: this.isUnique,
        isIndexed: this.isIndexed,
        isNotNullable: this.isNotNullable
      };
      refId.adapter.addToForeignTableSchema(table, foreignKeyConfig);
    }
  }
  getQueryConditions(dbPath) {
    return {
      [this.path + "_is_null"]: value => b => value ? b.whereNull(dbPath) : b.whereNotNull(dbPath)
    };
  }
}

var index$8 = {
  type: "Relationship",
  isRelationship: !0,
  implementation: Relationship,
  views: {
    Controller: resolveView("types/Relationship/views/Controller"),
    Field: resolveView("types/Relationship/views/Field"),
    Filter: resolveView("types/Relationship/views/Filter"),
    Cell: resolveView("types/Relationship/views/Cell")
  },
  adapters: {
    mongoose: MongoRelationshipInterface,
    knex: KnexRelationshipInterface
  }
};

function ownKeys$b(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread$b(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$b(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$b(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

function initOptions(options) {
  let optionsArray = options;
  return "string" == typeof options && (optionsArray = options.split(/\,\s*/)), Array.isArray(optionsArray) ? optionsArray.map(i => "string" == typeof i ? {
    value: i,
    label: inflection.humanize(i)
  } : i) : null;
}

const VALID_DATA_TYPES = [ "enum", "string", "integer" ], DOCS_URL = "https://keystonejs.com/keystonejs/fields/src/types/select/";

function validateOptions({options: options, dataType: dataType, listKey: listKey, path: path}) {
  if (!VALID_DATA_TYPES.includes(dataType)) throw new Error(`\n🚫 The select field ${listKey}.${path} is not configured with a valid data type;\n📖 see ${DOCS_URL}\n`);
  options.forEach((option, i) => {
    if ("enum" === dataType) {
      if (!/^[a-zA-Z]\w*$/.test(option.value)) throw new Error(`\n🚫 The select field ${listKey}.${path} contains an invalid enum value ("${option.value}") in option ${i}\n👉 You may want to use the "string" dataType\n📖 see ${DOCS_URL}\n`);
    } else if ("string" === dataType) {
      if ("string" != typeof option.value) {
        const integerHint = "number" == typeof option.value ? '\n👉 Did you mean to use the the "integer" dataType?' : "";
        throw new Error(`\n🚫 The select field ${listKey}.${path} contains an invalid value (type ${typeof option.value}) in option ${i}${integerHint}\n📖 see ${DOCS_URL}\n`);
      }
    } else if ("integer" === dataType && !Number.isInteger(option.value)) throw new Error(`\n🚫 The select field ${listKey}.${path} contains an invalid integer value ("${option.value}") in option ${i}\n📖 see ${DOCS_URL}\n`);
  });
}

class Select extends Field {
  constructor(path, {options: options, dataType: dataType = "enum"}) {
    super(...arguments), this.options = initOptions(options), validateOptions({
      options: this.options,
      dataType: dataType,
      listKey: this.listKey,
      path: path
    }), this.dataType = dataType, this.isOrderable = !0;
  }
  get _supportsUnique() {
    return !0;
  }
  gqlOutputFields() {
    return [ `${this.path}: ${this.getTypeName()}` ];
  }
  gqlOutputFieldResolvers() {
    return {
      ["" + this.path]: item => item[this.path]
    };
  }
  getTypeName() {
    return "enum" === this.dataType ? `${this.listKey}${inflection.classify(this.path)}Type` : "integer" === this.dataType ? "Int" : "String";
  }
  getGqlAuxTypes() {
    return "enum" === this.dataType ? [ `\n      enum ${this.getTypeName()} {\n        ${this.options.map(i => i.value).join("\n        ")}\n      }\n    ` ] : [];
  }
  extendAdminMeta(meta) {
    const {options: options, dataType: dataType} = this;
    return _objectSpread$b(_objectSpread$b({}, meta), {}, {
      options: options,
      dataType: dataType
    });
  }
  gqlQueryInputFields() {
    return [ ...this.equalityInputFields(this.getTypeName()), ...this.inInputFields(this.getTypeName()) ];
  }
  gqlUpdateInputFields() {
    return [ `${this.path}: ${this.getTypeName()}` ];
  }
  gqlCreateInputFields() {
    return [ `${this.path}: ${this.getTypeName()}` ];
  }
}

const CommonSelectInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$b(_objectSpread$b({}, this.equalityConditions(dbPath)), this.inConditions(dbPath));
  }
};

class MongoSelectInterface extends(CommonSelectInterface(adapterMongoose.MongooseFieldAdapter)){
  addToMongooseSchema(schema) {
    const options = "integer" === this.field.dataType ? {
      type: Number
    } : {
      type: String,
      enum: [ ...this.field.options.map(i => i.value), null ]
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(options, this.config)
    });
  }
}

class KnexSelectInterface extends(CommonSelectInterface(adapterKnex.KnexFieldAdapter)){
  constructor() {
    super(...arguments), this.isUnique = !!this.config.isUnique, this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }
  addToTableSchema(table) {
    let column;
    column = "enum" === this.field.dataType ? table.enu(this.path, this.field.options.map(({value: value}) => value)) : "integer" === this.field.dataType ? table.integer(this.path) : table.text(this.path), 
    this.isUnique ? column.unique() : this.isIndexed && column.index(), this.isNotNullable && column.notNullable(), 
    void 0 !== this.defaultTo && column.defaultTo(this.defaultTo);
  }
}

var index$9 = {
  type: "Select",
  implementation: Select,
  views: {
    Controller: resolveView("types/Select/views/Controller"),
    Field: resolveView("types/Select/views/Field"),
    Filter: resolveView("types/Select/views/Filter"),
    Cell: resolveView("types/Select/views/Cell")
  },
  adapters: {
    mongoose: MongoSelectInterface,
    knex: KnexSelectInterface
  }
};

function ownKeys$c(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread$c(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$c(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$c(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

class Text extends Field {
  constructor(path, {isMultiline: isMultiline}) {
    super(...arguments), this.isMultiline = isMultiline, this.isOrderable = !0;
  }
  get _supportsUnique() {
    return !0;
  }
  gqlOutputFields() {
    return [ this.path + ": String" ];
  }
  gqlOutputFieldResolvers() {
    return {
      ["" + this.path]: item => item[this.path]
    };
  }
  gqlQueryInputFields() {
    return [ ...this.equalityInputFields("String"), ...this.stringInputFields("String"), ...this.equalityInputFieldsInsensitive("String"), ...this.stringInputFieldsInsensitive("String"), ...this.inInputFields("String") ];
  }
  gqlUpdateInputFields() {
    return [ this.path + ": String" ];
  }
  gqlCreateInputFields() {
    return [ this.path + ": String" ];
  }
  extendAdminMeta(meta) {
    const {isMultiline: isMultiline} = this;
    return _objectSpread$c({
      isMultiline: isMultiline
    }, meta);
  }
}

const CommonTextInterface = superclass => class extends superclass {
  getQueryConditions(dbPath) {
    return _objectSpread$c(_objectSpread$c(_objectSpread$c(_objectSpread$c(_objectSpread$c({}, this.equalityConditions(dbPath)), this.stringConditions(dbPath)), this.equalityConditionsInsensitive(dbPath)), this.stringConditionsInsensitive(dbPath)), this.inConditions(dbPath));
  }
};

class MongoTextInterface extends(CommonTextInterface(adapterMongoose.MongooseFieldAdapter)){
  addToMongooseSchema(schema) {
    schema.add({
      [this.path]: this.mergeSchemaOptions({
        type: String
      }, this.config)
    });
  }
}

class KnexTextInterface extends(CommonTextInterface(adapterKnex.KnexFieldAdapter)){
  constructor() {
    super(...arguments), this.isUnique = !!this.config.isUnique, this.isIndexed = !!this.config.isIndexed && !this.config.isUnique;
  }
  addToTableSchema(table) {
    const column = table.text(this.path);
    this.isUnique ? column.unique() : this.isIndexed && column.index(), this.isNotNullable && column.notNullable(), 
    void 0 !== this.defaultTo && column.defaultTo(this.defaultTo);
  }
}

function ownKeys$d(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread$d(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$d(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$d(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

const MAX_UNIQUE_ATTEMPTS = 100, findFirstNonEmptyStringValue = fields => Object.values(fields).find(value => "string" == typeof value && value), generateSlug = valueToSlugify => slugify(valueToSlugify || "");

class SlugImplementation extends Text {
  constructor(path, {from: from, generate: generate, makeUnique: makeUnique, alwaysMakeUnique: alwaysMakeUnique = !1, isUnique: isUnique, regenerateOnUpdate: regenerateOnUpdate = !0}, {listKey: listKey}) {
    const listAndFieldPath = `${listKey}.${path}`;
    if ("boolean" != typeof regenerateOnUpdate) throw new Error(`The 'regenerateOnUpdate' option on ${listAndFieldPath} must be true/false`);
    if ("boolean" != typeof alwaysMakeUnique) throw new Error(`The 'alwaysMakeUnique' option on ${listAndFieldPath} must be true/false`);
    if (from && generate) throw new Error(`Only one of 'from' or 'generate' can be supplied as an option to the Slug field on ${listAndFieldPath}.`);
    let generateFn, makeUniqueFn;
    if (from) {
      if ("string" != typeof from) {
        if ("function" == typeof from) throw new Error(`A function was specified for the 'from' option on ${listAndFieldPath}, but 'from' exects a string. Did you mean to set the 'generate' option?`);
        throw new Error(`The 'from' option on ${listAndFieldPath} must be a string`);
      }
      generateFn = ({resolvedData: resolvedData, existingItem: existingItem}) => {
        if (!this.getListByKey(this.listKey).getFieldByPath(from)) throw new Error(`The field '${from}' does not exist on the list '${listKey}' as specified in the 'from' option of '${listAndFieldPath}'`);
        return generateSlug(_objectSpread$d(_objectSpread$d({}, existingItem), resolvedData)[from]);
      };
    } else if (generate) {
      if ("function" != typeof generate) throw new Error(`The 'generate' option on ${listAndFieldPath} must be a function, but received ${typeof generate}`);
      generateFn = async ({resolvedData: resolvedData, existingItem: existingItem}) => {
        const slug = await generate({
          resolvedData: resolvedData,
          existingItem: existingItem
        });
        if ("string" != typeof slug) throw new Error(`${listAndFieldPath}'s 'generate' option resolved with a ${typeof slug}, but expected a string.`);
        return slug;
      };
    } else generateFn = ({resolvedData: resolvedData, existingItem: existingItem}) => {
      const _existingItem$resolve = _objectSpread$d(_objectSpread$d({}, existingItem), resolvedData), {id: id, name: name, title: title} = _existingItem$resolve, fields = _objectWithoutProperties(_existingItem$resolve, [ "id", "name", "title" ]), valueToSlugify = name || title || findFirstNonEmptyStringValue(fields);
      if (!valueToSlugify) throw new Error("Unable to find a valid field to generate a slug for ${listAndFieldPath}. Please provide a `generate` method.");
      return generateSlug(valueToSlugify);
    };
    if (void 0 === makeUnique) makeUniqueFn = ({slug: slug}) => `${slug}-${cuid.slug()}`; else {
      if ("function" != typeof makeUnique) throw new Error(`The 'makeUnique' option on ${listAndFieldPath} must be a function, but received ${typeof makeUnique}`);
      makeUniqueFn = async ({slug: slug, previousSlug: previousSlug}) => {
        const uniqueifiedSlug = await makeUnique({
          slug: slug,
          previousSlug: previousSlug
        });
        if ("string" != typeof uniqueifiedSlug) throw new Error(`${listAndFieldPath}'s 'makeUnique' option resolved with a ${typeof uniqueifiedSlug}, but expected a string.`);
        return uniqueifiedSlug;
      };
    }
    const isUniqueCalculated = void 0 === isUnique || isUnique;
    super(arguments[0], _objectSpread$d(_objectSpread$d({}, arguments[1]), {}, {
      isUnique: isUniqueCalculated
    }), arguments[2]), this.isUnique = isUniqueCalculated, this.generateFn = generateFn, 
    this.makeUnique = makeUniqueFn, this.regenerateOnUpdate = regenerateOnUpdate, this.alwaysMakeUnique = alwaysMakeUnique, 
    this.isOrderable = !0;
  }
  async resolveInput({context: context, resolvedData: resolvedData, existingItem: existingItem}) {
    let slug;
    if (resolvedData[this.path]) slug = resolvedData[this.path]; else if (existingItem) if (this.regenerateOnUpdate) {
      const existingNonUniqueSlug = await this.generateFn({
        resolvedData: existingItem
      }), newNonUniqueSlug = await this.generateFn({
        resolvedData: resolvedData,
        existingItem: existingItem
      });
      slug = existingNonUniqueSlug === newNonUniqueSlug ? existingItem[this.path] : newNonUniqueSlug;
    } else slug = existingItem[this.path]; else slug = await this.generateFn({
      resolvedData: resolvedData
    });
    if (!this.isUnique && !this.alwaysMakeUnique) return slug;
    const listAndFieldPath = `${this.listKey}.${this.path}`;
    let uniqueSlug = slug;
    for (let i = 0; i < 100; i += 1) {
      (this.alwaysMakeUnique || i > 0) && (uniqueSlug = await this.makeUnique({
        slug: slug,
        previousSlug: uniqueSlug
      }));
      try {
        if (0 === (await serverSideGraphqlClient.getItems({
          context: context.createContext({
            skipAccessControl: !0
          }),
          listKey: this.listKey,
          where: _objectSpread$d({
            [this.path]: uniqueSlug
          }, existingItem && existingItem.id && {
            id_not: existingItem.id
          })
        })).length) return uniqueSlug;
      } catch (error) {
        throw new Error(`Attempted to generate a unique slug for ${listAndFieldPath}, but failed with an error: ${error.toString()}`);
      }
    }
    throw new Error(`Attempted to generate a unique slug for ${listAndFieldPath}, but failed after too many attempts. If you've passed a custom 'makeUnique' function, ensure it is working correctly`);
  }
}

const Slug = {
  type: "Slug",
  implementation: SlugImplementation,
  views: {
    Controller: resolveView("types/Text/views/Controller"),
    Field: resolveView("types/Text/views/Field"),
    Filter: resolveView("types/Text/views/Filter")
  },
  adapters: {
    knex: KnexTextInterface,
    mongoose: MongoTextInterface
  }
};

var index$a = {
  type: "Text",
  implementation: Text,
  views: {
    Controller: resolveView("types/Text/views/Controller"),
    Field: resolveView("types/Text/views/Field"),
    Filter: resolveView("types/Text/views/Filter")
  },
  adapters: {
    mongoose: MongoTextInterface,
    knex: KnexTextInterface
  }
}, index$b = {
  type: "Url",
  implementation: Text,
  views: {
    Controller: resolveView("types/Text/views/Controller"),
    Field: resolveView("types/Url/views/Field"),
    Filter: resolveView("types/Text/views/Filter"),
    Cell: resolveView("types/Url/views/Cell")
  },
  adapters: {
    mongoose: MongoTextInterface,
    knex: KnexTextInterface
  }
};

function ownKeys$e(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread$e(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$e(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$e(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

class UuidImplementation extends Field {
  constructor(path, {caseTo: caseTo = "lower"}) {
    super(...arguments), this.normaliseValue = a => a, caseTo && "upper" === caseTo.toString().toLowerCase() ? this.normaliseValue = a => a.toString().toUpperCase() : caseTo && "lower" === caseTo.toString().toLowerCase() && (this.normaliseValue = a => a.toString().toLowerCase()), 
    this.isOrderable = !0;
  }
  get _supportsUnique() {
    return !0;
  }
  gqlOutputFields() {
    return [ this.path + ": ID" ];
  }
  gqlOutputFieldResolvers() {
    return {
      ["" + this.path]: item => item[this.path]
    };
  }
  gqlQueryInputFields() {
    return [ ...this.equalityInputFields("ID"), ...this.inInputFields("ID") ];
  }
  gqlUpdateInputFields() {
    return [ this.path + ": ID" ];
  }
  gqlCreateInputFields() {
    return [ this.path + ": ID" ];
  }
}

const validator = a => "string" == typeof a && /^[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}$/.test(a);

class MongoUuidInterface extends adapterMongoose.MongooseFieldAdapter {
  addToMongooseSchema(schema, mongoose) {
    const schemaOptions = {
      type: mongoose.Schema.Types.String,
      validate: {
        validator: this.buildValidator(validator),
        message: "{VALUE} is not a valid UUID. Must be 8-4-4-4-12 hex format"
      }
    };
    schema.add({
      [this.path]: this.mergeSchemaOptions(schemaOptions, this.config)
    });
  }
  setupHooks({addPreSaveHook: addPreSaveHook, addPostReadHook: addPostReadHook}) {
    addPreSaveHook(item => {
      if (!(this.path in item)) return item;
      if (item[this.path]) {
        if ("string" != typeof item[this.path]) throw `Invalid UUID value given for '${this.path}'`;
        item[this.path] = this.field.normaliseValue(item[this.path]);
      } else item[this.path] = null;
      return item;
    }), addPostReadHook(item => (item[this.path] && (item[this.path] = this.field.normaliseValue(item[this.path])), 
    item));
  }
  getQueryConditions(dbPath) {
    return _objectSpread$e(_objectSpread$e({}, this.equalityConditions(dbPath, this.field.normaliseValue)), this.inConditions(dbPath, this.field.normaliseValue));
  }
}

class KnexUuidInterface extends adapterKnex.KnexFieldAdapter {
  constructor() {
    super(...arguments), this.field.isPrimaryKey || (this.isUnique = !!this.config.isUnique, 
    this.isIndexed = !!this.config.isIndexed && !this.config.isUnique);
  }
  addToTableSchema(table) {
    const column = table.uuid(this.path);
    this.field.isPrimaryKey ? column.primary().notNullable() : (this.isUnique ? column.unique() : this.isIndexed && column.index(), 
    this.isNotNullable && column.notNullable()), this.defaultTo && column.defaultTo(this.defaultTo);
  }
  addToForeignTableSchema(table, {path: path, isUnique: isUnique, isIndexed: isIndexed, isNotNullable: isNotNullable}) {
    if (!this.field.isPrimaryKey) throw `Can't create foreign key '${path}' on table "${table._tableName}"; '${this.path}' on list '${this.field.listKey}' as is not the primary key.`;
    const column = table.uuid(path);
    isUnique ? column.unique() : isIndexed && column.index(), isNotNullable && column.notNullable();
  }
  getQueryConditions(dbPath) {
    return _objectSpread$e(_objectSpread$e({}, this.equalityConditions(dbPath, this.field.normaliseValue)), this.inConditions(dbPath, this.field.normaliseValue));
  }
}

const Uuid = {
  type: "Uuid",
  implementation: UuidImplementation,
  views: {
    Controller: resolveView("types/Uuid/views/Controller"),
    Field: resolveView("types/Uuid/views/Field"),
    Filter: resolveView("types/Uuid/views/Filter")
  },
  adapters: {
    knex: KnexUuidInterface,
    mongoose: MongoUuidInterface
  },
  primaryKeyDefaults: {
    knex: {
      getConfig: client => {
        if ("postgres" === client) return {
          type: Uuid,
          knexOptions: {
            defaultTo: knex => knex.raw("gen_random_uuid()")
          }
        };
        throw `The Uuid field type doesn't provide a default primary key field configuration for the '${client}' knex client. You'll need to supply your own 'id' field for each list or use a different field type for your ids (eg '@keystonejs/fields-auto-increment').`;
      }
    },
    mongoose: {
      getConfig: () => {
        throw "The Uuid field type doesn't provide a default primary key field configuration for mongoose. You'll need to supply your own 'id' field for each list or use a different field type for your ids (eg '@keystonejs/fields-mongoid').";
      }
    }
  }
};

function ownKeys$f(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread$f(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$f(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$f(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

class Virtual extends Field {
  constructor(path, {resolver: resolver, graphQLReturnType: graphQLReturnType = "String", graphQLReturnFragment: graphQLReturnFragment = "", extendGraphQLTypes: extendGraphQLTypes = [], args: args = []}) {
    super(...arguments), this.resolver = resolver, this.args = args, this.graphQLReturnType = graphQLReturnType, 
    this.graphQLReturnFragment = graphQLReturnFragment, this.extendGraphQLTypes = extendGraphQLTypes;
  }
  get _supportsUnique() {
    return !1;
  }
  gqlOutputFields() {
    const argString = this.args.length ? `(${this.args.map(({name: name, type: type}) => `${name}: ${type}`).join("\n")})` : "";
    return [ `${this.path}${argString}: ${this.graphQLReturnType}` ];
  }
  getGqlAuxTypes() {
    return this.extendGraphQLTypes;
  }
  gqlOutputFieldResolvers() {
    return {
      ["" + this.path]: this.resolver
    };
  }
  gqlQueryInputFields() {
    return [];
  }
  extendAdminMeta(meta) {
    return _objectSpread$f(_objectSpread$f({}, meta), {}, {
      graphQLSelection: this.graphQLReturnFragment,
      isReadOnly: !0
    });
  }
  parseFieldAccess(args) {
    const parsedAccess = accessControl.parseFieldAccess(args), fieldDefaults = {
      create: !1,
      update: !1,
      delete: !1
    };
    return Object.keys(parsedAccess).reduce((prev, schemaName) => (prev[schemaName] = _objectSpread$f(_objectSpread$f({}, fieldDefaults), {}, {
      read: parsedAccess[schemaName].read
    }), prev), {});
  }
}

const CommonTextInterface$1 = superclass => class extends superclass {
  getQueryConditions() {
    return {};
  }
};

class MongoVirtualInterface extends(CommonTextInterface$1(adapterMongoose.MongooseFieldAdapter)){
  constructor() {
    super(...arguments), this.realKeys = [];
  }
  addToMongooseSchema() {}
}

class KnexVirtualInterface extends(CommonTextInterface$1(adapterKnex.KnexFieldAdapter)){
  constructor() {
    super(...arguments), this.realKeys = [];
  }
  addToTableSchema() {}
}

var index$c = {
  type: "Virtual",
  implementation: Virtual,
  views: {
    Controller: resolveView("types/Virtual/views/Controller"),
    Cell: resolveView("types/Virtual/views/Cell"),
    Field: resolveView("types/Virtual/views/Field"),
    Filter: resolveView("types/Virtual/views/Filter")
  },
  adapters: {
    mongoose: MongoVirtualInterface,
    knex: KnexVirtualInterface
  }
};

exports.CalendarDay = index, exports.Checkbox = index$1, exports.DateTime = DateTime, 
exports.DateTimeUtc = index$2, exports.Decimal = index$3, exports.File = index$4, 
exports.Float = index$5, exports.Implementation = Field, exports.Integer = index$6, 
exports.Password = index$7, exports.Relationship = index$8, exports.Select = index$9, 
exports.Slug = Slug, exports.Text = index$a, exports.Url = index$b, exports.Uuid = Uuid, 
exports.Virtual = index$c;
