"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty")), _objectWithoutProperties = _interopDefault(require("@babel/runtime/helpers/objectWithoutProperties")), core = require("@emotion/core"), fields = require("@arch-ui/fields"), React = require("react"), React__default = _interopDefault(React), input = require("@arch-ui/input"), _extends = _interopDefault(require("@babel/runtime/helpers/extends")), reactImage = require("react-image"), PropTypes = _interopDefault(require("prop-types")), octiconsReact = require("@primer/octicons-react"), loading = require("@arch-ui/loading"), lozenge = require("@arch-ui/lozenge"), button = require("@arch-ui/button"), layout = require("@arch-ui/layout"), theme = require("@arch-ui/theme");

function uploadButtonLabelFn({status: status}) {
  return "empty" === status ? "Upload File" : "Change File";
}

function cancelButtonLabelFn({status: status}) {
  switch (status) {
   case "stored":
    return "Remove File";

   case "removed":
    return "Undo Remove";

   case "updated":
   default:
    return "Cancel";
  }
}

function statusMessageFn({status: status}) {
  switch (status) {
   case "removed":
    return "save to remove";

   case "updated":
    return "save to upload";
  }
}

function errorMessageFn({type: type}) {
  switch (type) {
   case "save":
    return "Something went wrong, please reload and try again.";

   case "preview":
    return "Something went wrong, please try again.";
  }
}

class FileField extends React.Component {
  constructor(props) {
    super(props), _defineProperty(this, "onCancel", () => {
      this.props.onChange(this.originalFile), this.setState({
        changeStatus: this.originalFile ? "stored" : "empty",
        dataURI: null,
        errorMessage: null
      });
    }), _defineProperty(this, "onRemove", () => {
      this.setState({
        changeStatus: "removed",
        errorMessage: null
      }), this.props.onChange(null);
    }), _defineProperty(this, "onChange", ({target: {validity: validity, files: [file]}}) => {
      if (!file) return;
      const {errorMessage: errorMessage, onChange: onChange} = this.props, newState = {
        changeStatus: "updated"
      };
      validity.valid ? (file.type.includes("image") ? (this.getDataURI(file), newState.oldImagePath = this.getImagePath()) : this.state.dataURI && this.setState({
        dataURI: null,
        errorMessage: null
      }), onChange(file), this.setState(newState)) : this.setState({
        errorMessage: errorMessage({
          type: "save"
        })
      });
    }), _defineProperty(this, "openFileBrowser", () => {
      this.inputRef && this.inputRef.click();
    }), _defineProperty(this, "getFile", () => {
      const {value: value} = this.props, {changeStatus: changeStatus} = this.state, file = "removed" === changeStatus ? this.originalFile : value;
      return {
        file: file,
        type: file && file.__typename ? "server" : "client"
      };
    }), _defineProperty(this, "getDataURI", file => {
      const {errorMessage: errorMessage} = this.props, reader = new FileReader;
      reader.readAsDataURL(file), reader.onloadstart = () => {
        this.setState({
          isLoading: !0
        });
      }, reader.onerror = err => {
        console.error("Error with Cloudinary preview", err), this.setState({
          errorMessage: errorMessage({
            type: "preview"
          })
        });
      }, reader.onloadend = upload => {
        this.setState({
          isLoading: !1,
          dataURI: upload.target.result
        });
      };
    }), _defineProperty(this, "getImagePath", () => {
      const {dataURI: dataURI} = this.state, {file: file} = this.getFile();
      return file && file.mimetype && file.mimetype.includes("image") ? file.publicUrl : dataURI;
    }), _defineProperty(this, "getInputRef", ref => {
      this.inputRef = ref;
    }), _defineProperty(this, "renderUploadButton", () => {
      const {uploadButtonLabel: uploadButtonLabel, isDisabled: isDisabled} = this.props, {changeStatus: changeStatus, isLoading: isLoading} = this.state;
      return core.jsx(button.LoadingButton, {
        onClick: this.openFileBrowser,
        isLoading: isLoading,
        variant: "ghost",
        isDisabled: isDisabled
      }, uploadButtonLabel({
        status: changeStatus
      }));
    }), _defineProperty(this, "renderCancelButton", () => {
      const {cancelButtonLabel: cancelButtonLabel, isDisabled: isDisabled} = this.props, {changeStatus: changeStatus} = this.state;
      let appearance = "warning", onClick = this.onRemove;
      switch (changeStatus) {
       case "removed":
        appearance = "primary", onClick = this.onCancel;
        break;

       case "updated":
        onClick = this.onCancel;
      }
      return core.jsx(button.Button, {
        onClick: onClick,
        variant: "subtle",
        appearance: appearance,
        isDisabled: isDisabled
      }, cancelButtonLabel({
        status: changeStatus
      }));
    });
    const {value: _value} = props;
    this.originalFile = _value;
    const _changeStatus = this.originalFile ? "stored" : "empty";
    this.state = {
      changeStatus: _changeStatus,
      dataURI: null,
      errorMessage: null,
      isLoading: !1,
      oldImagePath: null
    };
  }
  render() {
    const {autoFocus: autoFocus, field: field, statusMessage: statusMessage, errors: errors, isDisabled: isDisabled} = this.props, {changeStatus: changeStatus, errorMessage: errorMessage} = this.state, {file: file} = this.getFile(), imagePath = this.getImagePath(), showStatusMessage = [ "removed", "updated" ].includes(changeStatus), htmlID = "ks-input-" + field.path;
    return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, {
      htmlFor: htmlID,
      field: field,
      errors: errors
    }), core.jsx(fields.FieldDescription, {
      text: field.adminDoc
    }), core.jsx(fields.FieldInput, null, file ? core.jsx(Wrapper, null, imagePath && core.jsx(ImageContainer, {
      src: imagePath,
      alt: field.path
    }), core.jsx(Content, null, core.jsx(layout.FlexGroup, {
      style: {
        marginBottom: theme.gridSize
      }
    }, this.renderUploadButton(), this.renderCancelButton()), errorMessage ? core.jsx(ErrorInfo, null, errorMessage) : core.jsx(layout.FlexGroup, {
      isInline: !0,
      growIndexes: [ 0 ]
    }, core.jsx(MetaInfo, {
      href: file.publicUrl
    }, file.filename || file.name), showStatusMessage ? core.jsx(ChangeInfo, {
      status: changeStatus
    }, statusMessage({
      status: changeStatus
    })) : null))) : this.renderUploadButton(), core.jsx(input.HiddenInput, {
      autoComplete: "off",
      autoFocus: autoFocus,
      id: htmlID,
      ref: this.getInputRef,
      name: field.path,
      onChange: this.onChange,
      type: "file",
      disabled: isDisabled
    })));
  }
}

_defineProperty(FileField, "propTypes", {
  cancelButtonLabel: PropTypes.func.isRequired,
  disabled: PropTypes.bool,
  errorMessage: PropTypes.func.isRequired,
  field: PropTypes.object,
  onChange: PropTypes.func.isRequired,
  statusMessage: PropTypes.func.isRequired,
  uploadButtonLabel: PropTypes.func.isRequired
}), _defineProperty(FileField, "defaultProps", {
  cancelButtonLabel: cancelButtonLabelFn,
  errorMessage: errorMessageFn,
  statusMessage: statusMessageFn,
  uploadButtonLabel: uploadButtonLabelFn
});

const Wrapper = props => core.jsx("div", _extends({
  css: {
    alignItems: "flex-start",
    display: "flex"
  }
}, props)), Content = props => core.jsx("div", _extends({
  css: {
    flex: 1,
    minWidth: 0
  }
}, props)), MetaInfo = props => core.jsx(lozenge.Lozenge, _extends({
  crop: "right"
}, props)), ErrorInfo = _ref => {
  let {children: children} = _ref, props = _objectWithoutProperties(_ref, [ "children" ]);
  return core.jsx(lozenge.Lozenge, _extends({
    style: {
      backgroundColor: theme.colors.R.L80,
      borderColor: "transparent",
      color: theme.colors.R.D20,
      display: "inline-flex"
    }
  }, props), core.jsx(octiconsReact.AlertIcon, {
    css: {
      marginRight: theme.gridSize
    }
  }), children);
}, appearanceMap = {
  default: "primary",
  removed: "danger",
  updated: "create"
}, ChangeInfo = _ref2 => {
  let {status: status = "default"} = _ref2, props = _objectWithoutProperties(_ref2, [ "status" ]);
  const appearance = appearanceMap[status];
  return core.jsx(lozenge.Lozenge, _extends({
    appearance: appearance
  }, props));
}, Image = ({src: imgSrc, alt: alt}) => {
  const {src: src} = reactImage.useImage({
    srcList: imgSrc
  });
  return core.jsx("img", {
    css: {
      display: "block",
      height: "auto",
      maxWidth: "100%"
    },
    src: src,
    alt: alt
  });
}, ImageContainer = props => core.jsx("div", {
  css: {
    backgroundColor: "white",
    borderRadius: theme.borderRadius,
    border: "1px solid " + theme.colors.N20,
    flexShrink: 0,
    marginRight: theme.gridSize,
    padding: "4px",
    position: "relative",
    textAlign: "center",
    width: 130
  }
}, core.jsx(ImageErrorBoundary, null, core.jsx(React.Suspense, {
  fallback: core.jsx(loading.LoadingIndicator, null)
}, core.jsx(Image, props))));

class ImageErrorBoundary extends React.Component {
  constructor(...args) {
    super(...args), _defineProperty(this, "state", {
      hasError: !1
    });
  }
  static getDerivedStateFromError() {
    return {
      hasError: !0
    };
  }
  render() {
    return this.state.hasError ? core.jsx("div", {
      css: {
        padding: "4px 0",
        color: theme.colors.N40
      }
    }, core.jsx("div", null, core.jsx(octiconsReact.FileMediaIcon, null)), core.jsx("span", {
      css: {
        fontSize: "0.9em"
      }
    }, "Could not load image")) : this.props.children;
  }
}

exports.default = FileField;
